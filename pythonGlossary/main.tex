\documentclass{ctexart}

\usepackage{listings}

\title{Python词汇表}
\author{杨资璋（翻译）}

\begin{document}
\maketitle
\section*{iterable}

可以一次返回它的一些成员的对象。iterable的例子包括所有的序列类型（例如list, str和tuple），一些非序列类型例如dict和文件对象，以及所有实现\lstinline{__iter__()}方法或者实现了序列语义的\lstlisting{__getitem__()}方法的类的对象。

iterable可以被用在for循环以及其他需要序列的地方（zip(), map(),...）。当iterable对象作为参数传入自建的iter()函数中时，它为对象返回一个iterator。对于遍历集合的值，这个iterator是很方便的。当使用iterable时，通常使用iter()或者直接处理iterator是不必要的。for语句会帮你自动处理——在循环过程中创建一个临时的未命名变量来存放iterator。也可以查看iterator, sequence和generator。

\section*{iterator}

一个表示数据流的对象。重复调用\lstinline{__next__()}方法（或者将它传入自建的\lstinline{next()}函数）将返回流中的连续物体。当没有更多的数据时，将产生\lstinline{StopIteration}异常。在这时，这个iterator对象已经枯竭，后续的\lstinline{__next__()}方法仅会产生\lstinline{StopIteration}异常。iterator被要求实现\lstinline{__iter__()}方法，\lstinline{__iter__()}方法会返回iterator对象本身所以每一个iterator也是iterable，并可以用于大多数其他iterable可以使使用的地方。一个值得注意的例外是试图多次迭代的代码。一个container对象（例如list）会在每次你将它传入\lstinline{iter()}函数或在for循环中使用它时产生一个全新的iterator。这样的尝试会返回与在之前迭代中枯竭的iterator对象相同的对象，导致它似乎是一个空的container。

\section*{generator}

一个返回generator iterator的函数。它看起来像一个普通的函数，除了它包含为了产生一系列可以在for循环中使用的值的或可以通过next()函数取回一个值的yield表达式。

通常指代一个generator函数，但是在某些语境下也指代一个\textit{generator iterator}。当在想要表达的意思不明确时，使用全称来避免歧义。

\section*{generator iterator}

通过generator函数产生的对象。

每一个yield会暂时暂停处理，记住当前位置的执行状况（包括局部变量和等待try语句）。当\textit{generator iterator}继续时，它会从离开的位置继续（与之相比的是在每次调用会从新开始的函数）。

\section*{generator expression}

返回一个iterator的表达式。它看起来像是一个正常表达式后跟随一个定义一个循环变量，range和可选的if部分的for部分。

\end{document}