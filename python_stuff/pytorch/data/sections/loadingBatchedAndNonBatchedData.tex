\documentclass[../main.tex]{subfile}

\begin{document}

\lstinline{DataLoader}支持通过\lstinline{batch_size}，\lstinline{drop_last}和\lstinline{batch_sampler}参数自动将每一个抓取的数据样本整理成批。

\subsection{自动形成批（默认）}

这是最常见的情形，对应于抓取数据的迷你批并将他们整理为批样本，也就是，包含有一个批维度的张量（通常是第一个）。

当\lstinline{batch_size}（默认为1）不是\lstinline{None}时，数据加载器得到的是样本的批而不是单独的样本。\lstinline{batch_size}和\lstinline{drop_last}参数指定了数据加载如何得到数据集键的批。对于映射形式的数据集，用户也可以选择指定每次得到一个键列表的\lstinline{batch_sampler}。

\textcolor{blue}{NOTE}：\lstinline{batch_size}和\lstinline{drop_last}参数实际上被用来从\lstinline{sampler}构建一个\lstinline{batch_sampelr}。对于映射形式的数据集，\lstinline{sampler}通过用户提供或者基于\lstinline{shuffle}参数构建。对于迭代形式的数据集，\lstinline{sampler}是一个虚假的无穷iterable。更多关于采样器的细节见\href{https://pytorch.org/docs/stable/data.html#data-loading-order-and-sampler}{这个部分}。

\textcolor{blue}{NOTE}：当配合使用迭代形式的数据集和多线程抓取时，\lstinline{drop_last}参数丢弃每一个工人的数据集备份的最后一个不满批。

在使用采样器的索引抓取了一个样本列表后，作为\lstinline{collate_fn}参数传入的函数将将样本列表整理成批。

在这种情况下，从一个映射形式的数据集加载大致等价于：
\begin{lstlisting}[language=Python]
for indices in batch_sampelr:
    yield collate_fn([dataset[i] for i in indices])
\end{lstlisting}
从一个迭代形式的数据集加载则大致等价于：
\begin{lstlisting}[language=Python]
dataset_iter = iter(dataset)
for indices in batch_sampler:
    yield collate_fn([next(dataset_iter) for _ in indices])
\end{lstlisting}

自定义的\lstinline{collate_fn}可以被用来自定义整理方式，例如，将序列化数据填充至批中的最大长度。关于\lstinline{collate_fn}的更多信息见\href{https://pytorch.org/docs/stable/data.html#dataloader-collate-fn}{这个部分}。

\subsection{关闭自动批形成}

在某些情况下，用户可能想在数据集代码中手动处理形成批的过程，或者简单地加载每个单独的样本。例如，直接加载成批的数据（例如，从一个数据库批读或者读取内存的连续块）可能更加便宜，或者批大小是数据相关的，或者程序被设计用来在单独的样本上工作。在这些情况下，似乎不适用自动成批（\lstinline{collate_fn}被用来整理样本）更好，而是让数据加载器直接返回\lstinline{dataset}对象的成员。

当\lstinline{batch_size}和\lstinline{batch_sampler}都是\lstinline{None}时（\lstinline{batch_sampler}的默认值便是\lstinline{None}），自动批形成将会关闭。从\lstinline{dataset}得到的每一个样本将会作为参数传入\lstinline{collate_fn}处理。

\textbf{当自动批形成关闭时}，默认的\lstinline{collate_fn}简单地将Numpy数组转化为PyTorch张量，并不做其他事情。

在这种情况下，从一个映射形式的数据集加载大致等价于：
\begin{lstlisting}[language=Python]
for index in sampler:
    yield collate_fn(dataset[index])
\end{lstlisting}
从一个迭代形式的数据集加载则大致等价于：
\begin{lstlisting}[language=Python]
for dat in iter(dataset):
    yield collate_fn(data)
\end{lstlisting}
关于\lstinline{collate_fn}的更多信息见\href{https://pytorch.org/docs/stable/data.html#dataloader-collate-fn}{这个章节}。

\subsection{和collate\_fn一起工作}

\lstinline{collate_fn}的用法在自动成批使能和关闭的情况下有所不同。

\textbf{当自动批形成关闭时}，\lstinline{collate_fn}通过每一个单独的数据样本调用，输出通过数据加载器iterator得到。在这种情况下，默认的\lstinline{collate_fn}简单地将Numpy数组转化为PyTorch张量。

\textbf{当自动成批使能时}，\lstinline{collate_fn}每次通过数据样本的列表调用。它应该将输入样本整理为从数据加载器iterator得到的批。这个章节的剩余内容描述了这种情况下\lstinline{collate_fn}的默认行为。

例如，如果每一个数据样本由一个三通道图片和一个整数类别标签组成，也就是，数据集的每一个成员返回一个\lstinline{(image, class_index)}元组，默认的\lstinline{collate_fn}将这样的元组列表整理为一个成批图片张量和成批类别标签张量的单独元组。特别的，默认的\lstinline{collaet_fn}有如下性质：
\begin{itemize}
    \item 它总是添加一个作为批维度的新维度
    \item 它自动将NumPy数组和Python数值转化为PyTorch张量
    \item 它保留数据的结构，例如，如果每一个样本是一个字典，它输出一个拥有相同键但是值换为了批张量（如果值无法转化为张量，则是列表）。对于\lstinline{list}, \lstinline{tuple}和\lstinline{namedtuple}等处理方式相同
\end{itemize}

用户可以使用自定义的\lstinline{collate_fn}来实现自定义成批过程，例如，沿着其他而不是第一个维度成批，填充不同长度的序列或者增添对自定义数据类型的支持。

\end{document}