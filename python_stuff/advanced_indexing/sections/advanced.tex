\documentclass[../main.tex]{subfile}
\begin{document}

当选择对象\lstinline{obj}是非元组序列对象、整数或bool的\lstinline{ndarray}或者一个有着至少一个序列对象或整数或bool的\lstinline{ndarray}的元组时，高级索引将会被触发。共有两种高级索引类型：整数和Boolean。

高级索引总是返回数据的\textit{备份}（与返回视图的基本索引相反）。

\paragraph{Warning}高级索引的定义意味着\lstinline{x[(1, 2, 3), ]}与\lstinline{x[(1,2,3)]}是完全不同的。后者与\lstinline{x[1, 2, 3]}等价，将会触发基本索引，而后者则会触发高级索引。确保你明白为什么这会发生。同时注意\lstinline{x[[1, 2, 3]]}也会触发高级索引，然而由于前面提到的丢弃的数值兼容性，\lstinline{x[[1,2,slice(None)]]}将会触发基本索引。

\subsection{整数数组索引}

整数数组索引允许根据$N$维索引选择数组中的任意项。每个整数数组表示该维度的多个索引。

\subsubsection{纯整数数组索引}

当索引由与被索引数组的维度一样多的整数数组组成时，索引是直接的，但与切片不同。

高级索引总是被广播并作为\textit{一个}被迭代：
\begin{lstlisting}
    result[i_1, ..., i_M] == x[ind_1[i_1, ..., i_M], ind_2[i_1, ..., i_M],
                           ..., ind_N[i_1, ..., i_M]]
\end{lstlisting}
注意结果的形状与广播的索引数组形状（\lstinline{ind_1, ..., ind_N}）是相同的。

为了实现和上述基本切片相似的行为，可以使用广播。函数\href{https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_}{\lstinline{ix_}}可以帮助这个广播。这最好通过例子理解。

\paragraph{Example}使用高级索引，角元素应该从一个$4\times 3$的数组中被选择出来。因此所有列在\lstinline{[0, 2]}同时行在\lstinline{[0, 3]}的元素应该被选出来。为了使用高级索引，需要\textit{显式}选择每一个元素。使用之前解释的方法，可以使用如下代码：
\begin{lstlisting}
>>> x = np.array([[ 0,  1,  2],
...               [ 3,  4,  5],
...               [ 6,  7,  8],
...               [ 9, 10, 11]])
>>> rows = np.array([[0, 0],
                     [3, 3],], dtype=np.intp)
>>> columns = np.array([[0, 2], 
                        [0, 2], dtype=np.intp])
>>> x[rows, columns]
array([[0, 2], 
       [9, 11]])
\end{lstlisting}
然而，由于上面的索引数组仅仅是在重复它们自己，所有可以使用广播（）来简化：
\begin{lstlisting}
>>> rows = np.array([0, 3], dtype=np.intp)
>>> columns = np.array([0, 2], dtype=np.intp)
>>> rows[:, np.newaxis]
array([[0],
       [3]])
>>> x[rows[:, np.newaxis], columns]
array([[ 0,  2],
       [ 9, 11]])
\end{lstlisting}
这个广播也可以通过\href{https://numpy.org/doc/stable/reference/generated/numpy.ix_.html#numpy.ix_}{\lstinline{ix_}}函数实现：
\begin{lstlisting}
>>> x[np.ix_(rows, columns)]
array([[ 0,  2],
       [ 9, 11]])
\end{lstlisting}
注意在之前的例子中没有使用\lstinline{np.ix_}，只有对角线元素被选择了。这个不同是关于使用多个高级索引进行索引最重要的事情。

\subsubsection{将高级和基本索引结合}

当索引中存在至少一个切片（\lstinline{:}，省略号（\lstinline{...}）或（ \lstinline{newaxis}）时，这时行为可能变得更加复杂。它就像为每一个高级索引元素拼接它们的索引结果。

在最简单的例子中，仅存在一个高级索引。一个单独的高级索引可以替换一个切片并得到相同的结果，然而，它是一个备份并可能有不同内内存布局。当可能时，切片是更好的。

\paragraph{Example}
\begin{lstlisting}
>>> x[1:2, 1:3]
array([[4, 5]])
>>> x[1:2, [1, 2]]
array([[4, 5]])
\end{lstlisting}

理解这种情况最简单的方式也许是考虑结果的形状。索引操作共有两部分，通过基本索引定义的子空间和通过高级索引定义的子空间。需要搞清楚索引结合的两种情况：
\begin{itemize}
    \item 高级索引被切片、省略号或者\lstinline{newaxis}分开。例如\lstinline{x[arr1, :, arr2]}
    \item 所有的高级索引彼此紧贴。例如\lstinline{x[..., arr1, arr2, :]}，但\lstinline{x[arr1, :, 1]}则不属于这种情况，在这里\lstinline{1}被视为高级索引
\end{itemize}

在第一种情况，高级索引操作得到的维度首先出现在结果数组中，然后是子空间维度。在第二种情况，来自高级索引操作的维度被插入到与它们在初始数组中相同的结果数组中的位置（后一种逻辑使简单高级索引的行为就像切片一样）。

\paragraph{Example}假设\lstinline{x.shape}为(10, 20, 30)，\lstinline{ind}是形状为(2, 3, 4)的intp数组，那么由于(20, )的子空间被替换为了(2, 3, 4)的广播后的索引子空间，所以\lstinline{result = x[..., ind, :]}的形状为(10, 2, 3, 4, 30)。如果我们让\lstinline{i, j, k}遍历形状为(2, 3, 4)的子空间，这时\lstinline{result[..., i, j, k, :] = x[..., ind[i, j, k], :]}。这个例子产生与\lstinline{x.take(ind, axis=-2)}相同的结果。

\paragraph{Example}假设\lstinline{x.shape}为(10, 20, 30, 40, 50)，\lstinline{ind_1}和\lstinline{ind_2}可以广播为(2, 3, 4)。这时由于形状为(20, 30)的子空间被替换为来自索引的(2, 3, 4)子空间，所以\lstinline{x[:, ind_1, ind_2]}的形状为(10, 2, 3, 4, 40, 50)。然而，由于在索引子空间中没有明确的地方可以删除，因此它被添加到了开头，所以\lstinline{x[:, ind_1, :, ind_2]}的形状为(2, 3, 4, 10, 30, 50)。使用\lstinline{.transpose()}来将子空间移动到任意需要的位置一直是可行的。注意这个例子无法通过\lstinline{take}复现。

\subsection{boolean数组索引}

当\lstinline{obj}是例如可能从比较运算符返回的布尔类型的数组对象时，就会发生这种高级索引。单个布尔索引数组实际上与\lstinline{x[obj.nonzero()]}相同，其中，如上所述，\lstinline{obj.nonzero()}返回整数索引数组的元组（长度为\lstinline{obj.ndim}），显示\lstinline{obj}的\lstinline{True}元素。但是，当\lstinline{obj.shape == x.shape}时，它的速度更快。

如果\lstinline{obj.ndim == x.ndim}，则\lstinline{x[obj]}返回一个一维数组，其中填充了与\lstinline{obj}的\lstinline{True}值对应的\lstinline{x}元素。 搜索顺序将是行优先，C 样式。 如果\lstinline{obj}在\lstinline{x}边界之外的条目处具有\lstinline{True}值，则将引发索引错误。 如果\lstinline{obj}小于\lstinline{x}，则使用\lstinline{False}进行填充。

\paragraph{Example}一个常见的用例是过滤所需的元素值。 例如，您可能希望从数组中选择所有不是 \lstinline{NaN} 的条目：
\begin{lstlisting}
>>> x = np.array([[1., 2.], [np.nan, 3.], [np.nan, np.nan]])
>>> x[~np.isnan(x)]
array([1., 2., 3.])
\end{lstlisting}
或者希望为所有负元素添加一个常量：
\begin{lstlisting}
>>> x = np.array([1., -1., -2., 3])
>>> x[x < 0] += 20
>>> x
array([  1.,  19.,  18.,   3.])
\end{lstlisting}

通常，如果索引包含布尔数组，结果将与将\lstinline{obj.nonzero()}插入相同位置并使用上述整数数组索引机制相同。\lstinline{x[ind_1, boolean_array, ind_2]}等价于\lstinline{x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]}。

如果只有一个布尔数组而没有整数索引数组，这很简单。只需要注意确保布尔索引具有与它应该使用的维度一样多的维度。

\paragraph{Example}从数组中，选择总和小于或等于 2 的所有行：
\begin{lstlisting}
>>> x = np.array([[0, 1], [1, 1], [2, 2]])
>>> rowsum = x.sum(-1)
>>> x[rowsum <= 2, :]
array([[0, 1],
       [1, 1]])
\end{lstlisting}

使用\lstinline{obj.nonzero()}类比可以最好地理解组合多个布尔索引数组或布尔与整数索引数组。 函数\lstinline{ix_}也支持布尔数组并且可以正常工作。

\paragraph{Example}使用布尔索引选择加起来为偶数的所有行。 同时，应使用高级整数索引选择列\lstinline{0}和\lstinline{2}。 使用\lstinline{ix_}函数可以通过以下方式完成：
\begin{lstlisting}
>>> x = np.array([[ 0,  1,  2],
[ 3,  4,  5],
[ 6,  7,  8],
[ 9, 10, 11]])
>>> rows = (x.sum(-1) % 2) == 0
>>> rows
array([False,  True, False,  True])
>>> columns = [0, 2]
>>> x[np.ix_(rows, columns)]
array([[ 3,  5],
[ 9, 11]])
\end{lstlisting}
如果没有\lstinline{np.ix_}调用，只会选择对角线元素。或者没有\lstinline{np.ix_}（比较整数数组示例）：
\begin{lstlisting}
>>> rows = rows.nonzero()[0]
>>> x[rows[:, np.newaxis], columns]
array([[ 3,  5],
       [ 9, 11]])
\end{lstlisting}

\end{document}