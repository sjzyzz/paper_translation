\documentclass[../main.tex]{subfile}

\begin{document}

这篇文档解释了数据集API(DatasetCatalog, MetadataCatalog)是如何工作的，以及如何使用它们来添加自定义的数据库

在detectron2中集成支持的数据里列在了\href{https://detectron2.readthedocs.io/en/latest/tutorials/builtin_datasets.html}{这里}。如果你想使用自定义的数据集同时复用detectron2的数据加载器，你需要做的是：
\begin{itemize}
    \item 注册你的数据集(也就是，告诉detectron2如何得到你的数据集)
    \item 以及可选的，为你的数据集注册元数据
\end{itemize}
接下来，我们详细解释以上两个概念

\subsection{注册数据集}

为了让detectron2知道如何得到名为“my\_dataset”的数据集，用户需要实现一个返回数据集中的物体的函数并告诉detectron2这个函数：

\begin{lstlisting}[language=Python]
def my_dataset_function():
...
return list[dict] in the following format
from detectron2.data import DatasetCatalog
DatasetCatalog.register("my_dataset", my_dataset_function)
# later, to access the data:
data: List[Dict] = DatasetCatalog.get("my_dataset")
\end{lstlisting}

这里，这个代码段将名为“my\_dataset”的数据集和返回数据的函数关联了起来。如果这个函数被多次使用，那么它必须按照相同的顺序返回相同的数据。知道进程结束，这个注册一直有效。

这个函数可以做任意的事情并应该返回\lstinline{list[dict]}形式的数据，每一个dict应该是如下的一种格式：

\begin{itemize}
    \item 下面将要描述的detectron2的标准数据集字典。这将会使它可以和detectron2的集成支持特性一同工作，所以当可行时，这是推荐的方式
    \item 任何自定义的格式。你也可以返回任意自定格式的字典，例如为新任务添加额外的键。这是你将需要在下游任务中合适地处理它们。下面将会展示更多细节。
\end{itemize}

\subsubsection{标准数据集字典}

对于标准任务（实例检测、实例/语义/全景分割和关键点检测），我们以类似于COCO标注的规范将原本的数据集载入\lstinline{list[dict]}。这是我们对于数据集的标准表示。

每一个字典包含一张图片的信息。字典可能有如下的域，以及要求的域随着数据加载器和任务的需要而变化（更多见下表）。

% | **任务** | **域** |
% |---------|--------|
% |共同的|file_name, height, width, image_id|
% |实例检测/分割|annotations|
% |语义分割|sem_seg_file_name|
% |全景分割|pan_seg_file_name, segments_info|


\begin{itemize}
    \item \lstinline{file_name}：图片文件的完全路径
    \item \lstinline{height, width}：整数。图片的形状
    \item \lstinline{image_id}：字符串或者整数。可以识别图片的唯一id。许多评价者为了识别图片可能会要求，但是数据集也可以处于不同的目的使用它
    \item \lstinline{annotations}(list[dict])：实例检测/分割或者关键点检测任务要求这个域。每一个字典对应于图片中一个实例的标注，可能包含如下键：
          \begin{itemize}
              \item \lstinline{bbox}(list[float])：表示实例边界框的包含四个数字的列表
              \item \lstinline{bbox_mode}(int)：边界框的格式。它一定是\href{https://detectron2.readthedocs.io/en/latest/modules/structures.html#detectron2.structures.BoxMode}{structrues.BoxMode}中的一员。目前支持：\lstinline{BoxMode.XYXY_ABS}和\lstinline{BoxMode.XYWH_ABS}
              \item \lstinline{category_id}(int)：一个[0, num\_categories-1]中的整数，表示类别标签。如果需要，num\_categories被保留用来表示“背景”类别。
              \item \lstinline{segmentation}(list[list[float]]或者dict)：实例的分割掩码
                    \begin{itemize}
                        \item 如果是\lstinline{list[list[float]]}形式，它表示一个多边形列表，其中每一个多边形表示物体的连接的组分。每一个\lstinline{list[float]}是一个格式为\lstinline{[x1, y1, ..., xn, yn]}（n≥3）的简单多边形。其中Xs和Ys是单位像素下的绝对坐标。
                        \item 如果是\lstinline{dict}形式，它表示
                    \end{itemize}
              \item \lstinline{keypoints}
          \end{itemize}
    \item \lstinline{sem_seg_file_name}
    \item \lstinline{pan_seg_file_name}
    \item \lstinline{segments_info}
          \begin{itemize}
              \item \lstinline{id}
              \item \lstinline{category_id}
              \item \lstinline{iscrowd}
          \end{itemize}
\end{itemize}

\subsubsection{为了新任务自定义数据集字典}

在你的数据集函数返回的\lstinline{list[dict]}中，这个字典也可以包含\textbf{任意自定义的数据}。这对于需要使用没有被标准数据字典包含的额外信息的新任务有帮助。在这种情况下，你需要保证下游代码可以正确处理你的数据。这经常要求为数据加载器写一个新的\lstinline{mapper}（见\href{https://detectron2.readthedocs.io/en/latest/tutorials/data_loading.html}{使用自定义数据加载器}）。

当设计一个自定义格式时，注意所有的字典都储存在内存中（有时被序列化并有多份拷贝）。为了节约内存，每个字典应该包含关于每个样本少但是充分的信息，例如文件名和标注。加载全部样本通常在数据加载器中发生。

对于在整个数据集中共享的属性，使用\lstinline{Metadata}（见后文）。为了避免额外的内存，不要将这种信息存在每一个样本中。

\subsection{数据集的元数据}

每个数据集斗鱼某些元数据向关联，可以通过\lstinline{MetadataCatalog.get(dataset_name).some_metadata}访问。元数据是包含整个数据集共享的信息的键值对映射，通常被用来解释数据集中有什么，例如，类别的名字、类别的颜色和根文件等等。这些信息对于数据增强、评估、可视化和日志等很有用。元数据的结构取决于对应下游代码中的需要。

如果你通过\lstinline{DatasetCatalog.register}注册了一个新数据集，为了附能一些需要元数据的特性，你可能也想通过\lstinline{MetadataCatalog.get(dataset_name).some_key = some_value}来添加它对应的元数据。你可以这样做（使用元数据键“thing\_classes”作为例子）：

\begin{lstlisting}[language=Python]
from detectron2.data import MetadataCatalog
MetadataCatalog.get("my_dataset").thing_classes = ["person", "dog"]
\end{lstlisting}

这里是使用detectron2内建特性的元数据列表。如果你在没有这些元数据的情况下添加了你自己的数据集，某些特性可能不可用：
\begin{itemize}
    \item \lstinline{thing_classes}
    \item \lstinline{thing_colors}
    \item \lstinline{stuff_classes}
    \item \lstinline{ignore_label}
    \item \lstinline{keypoint_names}
    \item \lstinline{keypoint_flip_map}
    \item \lstinline{keypoint_connection_rules}
\end{itemize}

一些额外的为了评估某些数据集（例如COCO）的特定元数据
\begin{itemize}
    \item \lstinline{thing_dataset_id_to_contiguous_id}
    \item \lstinline{stuff_dataset_id_to_contiguous_id}
    \item \lstinline{json_file}
    \item \lstinline{panoptic_root}和\lstinline{panoptic_json}
    \item \lstinline{evaluator_type}
\end{itemize}

\subsection{注册一个COCO格式的数据集}

如果你的实例层级（检测、分割和关键点）数据集已经是COCO格式下的json文件，这个数据集以及它关联的元数据可以如下轻易注册：
\begin{lstlisting}[language=Python]
from detectron2.data.datasets import register_coco_instances
register_coco_instances("my_dataset", {}, "json_annotation.json", "path/to/image/dir")
\end{lstlisting}
如果你的数据集是COCO的格式但是需要进一步处理，或者有额外的自定义标注，\href{https://detectron2.readthedocs.io/en/latest/modules/data.html#detectron2.data.datasets.load_coco_json}{load\_coco\_json}函数可能会有用。

\subsection{为了新的数据集更新配置}

一旦你注册了数据集，你可以在\lstinline{cfg.DATASETS.TRAIN/TEST}中使用数据集的名字。这里还有一些其他的你为了在新的数据集上训练或者评测可能想要改变的配置：
\begin{itemize}
    \item \lstinline{MODEL.ROI_HEAD.NUM_CLASSES}和\lstinline{MODEL.RETINANET.NUM_CLASSES}
    \item \lstinline{MODEL.ROI_KEYPOINT_HEAD.NUM_KEYPOINTS}
    \item \lstinline{MODEL>SEM_SEG_HEAD.NUM_CLASSES}
    \item \lstinline{TEST.DETECTIOND_PER_IMAGE}
    \item \lstinline{DATASETS.PROPOSAL_FILES_TRAIN\TEST}
\end{itemize}
新的模型经常有它们自己类似的需要更改配置。

\end{document}