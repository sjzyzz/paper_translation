\documentclass[../main.tex]{subfile}

\begin{document}

数据加载器是为模型提供数据的模块。一个数据加载器通常（但并不是一直）使用来自数据集的未加工信息，并且将它们处理为模型需要的格式

\subsection{现有的数据加载器是如何工作的}

detectron2包含一个内建的数据加载流水线。理解它是如何工作是好的，万一你需要自己写一个呢。

detectron2提供了两个函数\href{https://detectron2.readthedocs.io/en/latest/modules/data.html#detectron2.data.build_detection_train_loader}{build\_detection\_train/test\_loader}来从给定的配置创建数据加载器。这里介绍\lstinline{build_detection_train/test_loader}是如何工作的：
\begin{itemize}
    \item 它接收一个已经注册数据集的名字（例如，"coco\_2017\_train"）并加载一个以轻量化格式表示数据集项的\lstinline{list[dict]}。这些数据集项并没有准备好被模型使用（例如，图片还没有被载入内存、随机的数据增强还没有被应用等等）。数据集格式和数据集注册的细节可以在[这里](https://detectron2.readthedocs.io/en/latest/tutorials/datasets.html)被找到。
    \item 列表中的每一个dict都会被函数（“mapper”）映射：
          \begin{itemize}
              \item 用户可以通过指定\lstinline{build_detection_train/test_loader}中的“mapper”参数来自定义这个映射函数。默认的mapper是\href{https://detectron2.readthedocs.io/en/latest/modules/data.html#detectron2.data.DatasetMapper}{DatasetMapper}
              \item mapper的输出格式可以使任意的，只要它被这个数据加载器的消费者（通常是模型）接受。默认mapper的输出，在batching后，遵循\href{https://detectron2.readthedocs.io/en/latest/tutorials/models.html#model-input-format}{Use Model}中指出的默认的模型输入格式。
              \item mapper的作用是将数据集项的轻量化表示转化为准备好模型使用的格式（包括，例如读入图片、进行随机的数据增强和转化为torch张量）。如果你想要对数据进行自定义的转化，你经常想要写一个自定义的mapper
          \end{itemize}
    \item mapper的输出是batched（简单的放入一个列表中）
    \item 这个batched数据就是数据加载器的输出。一般来说，也是\lstinline{model.forward()}的输入
\end{itemize}

\subsection{写一个自定义的数据加载器}

使用不同mapper的\lstinline{build_detection_train/test_loader}适用大部分自定义数据加载的情况。例如，如果你为了训练想将所有的图片裁剪为固定的尺寸，使用：

\begin{lstlisting}[language=Python]
    import detectron2.data.transforms as T
    from detectron2.data import DatasetMapper
    dataloader = build_detection_train_loader(cfg, mapper=DatasetMapper(cfg, is_train=True, augmentations=[T.Reszie((800, 800))]))
\end{lstlisting}

如果默认\href{https://detectron2.readthedocs.io/en/latest/modules/data.html#detectron2.data.DatasetMapper}{DatasetMapper}的参数没有提供你需要的，你可以写一个自己的mapper函数并使用它，例如：

\begin{lstlisting}[language=Python]
    from detectron2.data import detection_utils as utils
    def mapper(dataset_dict):
        dataset_dict = copy.deepcopy(dataset_dict)
        image = utils.read_image(dataset_dict["file_name"], format="BGR")
        auginput = T.AugInput(image)
        transfrom = T.Resize((800, 800))(auginput)
        image = torch.from_numpy(auginput.image.transpose(2, 0, 1))
        annos = [
            utils.transform_instance_annotations(annotation, [transform], image.shape[1:])
            for annotation in dataset_dict.pop("annotations")    
        ]
        return {
            "image":image,
            "instances": utils.annotations_to_instances(annos, image.shape[1:])
        }
    dataloader = build_detection_train_loader(cfg, mapper=mapper)
\end{lstlisting}

如果你不仅想改变mapper（例如，为了实现不同的采样或者batching逻辑），那么\lstinline{build_detection_train/test_loader}不再适用，你需要写一个不同的数据加载器。数据加载器就是一个生产模型接受格式的Python的迭代器。你可以通过任何你喜欢的工具实现它。

无论实现什么，我们推荐你去查看\href{https://detectron2.readthedocs.io/en/latest/modules/data.html}{API documentation of detectron2.data}来学习更多关于这些函数的API。

\subsection{使用一个自定义的数据加载器}

如果你使用\href{https://detectron2.readthedocs.io/en/latest/modules/engine.html#detectron2.engine.defaults.DefaultTrainer}{DefaultTrainer}，你可以重写它的\lstinline{build_train/test_loader}来使用你自己的数据加载器。例子可见\href{https://github.com/facebookresearch/detectron2/blob/master/projects/DeepLab/train_net.py}{deeplab dataloader}

如果你要写自己的训练循环，你可以轻易的插入你的数据加载器
\end{document}