\documentclass[../main]{subfile}

\begin{document}

增强是训练的重要部分。detectron2的数据增强系统意在达到如下目标：
\begin{itemize}
    \item 允许同时增强多个数据类型（例如，和图片一起的边界框和掩码）
    \item 允许应用一系列静态声明的增强
    \item 允许为增强添加自定义的新数据类型（旋转边界框，视频片段等等）
    \item 处理和操作由增强应用的操作
\end{itemize}
前两个特性包含了大部分通产使用的情况，并且在例如\href{https://medium.com/pytorch/multi-target-in-albumentations-16a777e9006e}{albumentations}的其他库中也可用。支持其他特性为detectron2的增强API添加了一些优势，这也是我们将会在这个教程中解释的

这个教程聚焦于当写新的数据加载器时如何使用增强，以及如何写新的增强。如果你使用detctron2中的默认数据加载器，正如\href{https://detectron2.readthedocs.io/en/latest/tutorials/data_loading.html}{Dataloader tutorial}中解释的，它已经支持接收一个用户提供的自定义增强列表

\subsection{基本用法}

特征1和特征2的基本用法如下：

\begin{lstlisting}[language=Python]
from detectron2.data import transforms as T
# 定义一个增强序列
augs = T.AugmentationList([
    T.RandomBrightness(0.9, 1.1),
    T.RandomFlip(prob=0.5),
    T.RandomCrop("absolute", (640, 640))
]) # 类型：T.Augmentation
# 定义增强输入
input = T.AugInput(image, boxes=boxes, sem_seg=sem_seg)
# 应用增强
transform = augs(input)
image_transfomed = input.image # 新图片
sem_seg_transformed = input.sem_seg # 新语义分割

# 对于其他需要被一起增强的额外数据，使用transform，例如：
image2_transformed = transform.apply_image(mage2)
polygons_transformed = transform.apply_polygons(polygons)
\end{lstlisting}

这里涉及三个基本概念：
\begin{itemize}
    \item T.Augmentation定义了需改输入的\textbf{政策}
          \begin{itemize}
              \item 它的\lstinline{__call__(AugInput) -> Transform}通过in-place的方式增强数据，并且返回应用的操作
          \end{itemize}
    \item T.Transform实现了真正的变形数据的操作
          \begin{itemize}
              \item 它有例如\lstinline{apply_image}和\lstinline{apply_coords}的方法来定义如何为每一种数据类型变形
          \end{itemize}
    \item T.AugInput存储了\lstinline{T.Augmentation}需要的输入以及它们应该如何变形。一些高阶用法需要这个概念。如上所示，由于没在\lstinline{T.AugInput}中的额外数据可以通过使用返回的\lstinline{transform}增强，所以直接使用这个类对于所有常用情形应该是足够的。
\end{itemize}

\subsection{写新的增强}

大部分二维增强只需要知道数据图像。这样的增强可以如下轻易实现：

\begin{lstlisting}[language=Python]
class MyColorAugmentation(T.Augmentation):
    def get_transform(self, image):
        r = np.random.rand(2)
        return T.ColorTransform(lambda x: x * r[0] + r[1] * 10)

class MyCustonResize(T.Augmentation):
    def get_transform(self.image):
        old_h, old_w = image.shape[:2]
        new_h, new_w = int(old_h * np.random.rand()), int(old_w * 1.5)
        return T.ResizeTransform(old_h, old_w, new_h, new_w)

augs = MyCustomResize()
transform = augs(input)
\end{lstlisting}

除了图片，只要他们是函数签名的一部分，给定\lstinline{AugInput}的任意属性都可以被使用，例如：

\begin{lstlisting}[language=Python]
class MyCustomCrop(T.Augmentation):
    def get_transform(self, image, sem_seg):
        # decide where to crop using both image and sem_seg
        return T.CropTransform(...)

augs = MyCustomCrop()
assert hasattr(input, "image") and hasattr(input, "sem_seg")
transform = augs(input)
\end{lstlisting}

新的变形操作也可以通过继承\href{https://detectron2.readthedocs.io/en/latest/modules/data_transforms.html#detectron2.data.transforms.Transform}{T.Transform}来添加

\subsection{高级用法}

我们提供了一些我们的系统使能的高级用法的例子。虽然对于标准使用的情形来说修改它们是不必要的，但是这些选项可能对于新研究来说很有趣。

\subsubsection{自定义变形策略}

detectron2的\lstinline{Augmentation}并不是仅仅返回增强的数据，而是返回\lstinline{T.Transform}形式的\textbf{操作}。这允许用户对数据使用自定义的变形策略。我们使用关键点数据作为例子。

关键点是(x, y)坐标，但是由于它们携带的语义信息，所以增强它们并不容易。只有用户知道这样的含义，因此用户想根据返回的\lstinline{transform}来手动增强它们。例如，当一个图片是水平翻转的，我们希望将关键点标注“左眼”和“右眼”对换。这可以通过如下代码实现（这被detectron2的默认数据加载器包含在内）:

\begin{lstlisting}[language=Python]
# augs和input在之前的例子中定义
transfom = augs(input)
keypoints_xy = transform.apply_coords(keypoints_xy)

# 得到一个所有的应用的transform的列表
transforms = T.TransformList([transform]).transforms
# 检查是否翻转了奇数次
do_hflip = sum(isinstance(t, T.HFlipTransform) for t in transforms) % 2 == 1
if do_hflip:
    keypoints_xy = keypoints_xy[flip_indices_mapping]
\end{lstlisting}
\end{document}